% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/UtilityFunctions.R
\name{prepareTargetDataLegacy}
\alias{prepareTargetDataLegacy}
\title{USGS Lidar Toolkit -- Prepare Target Data}
\usage{
prepareTargetDataLegacy(
  x,
  y,
  buffer = 0,
  shape = "square",
  aoi = "",
  crs = "",
  segments = 60,
  returnType = "sf"
)
}
\arguments{
\item{x}{Location or list of locations containing the easting for the center of
the area-of-interest.}

\item{y}{Location or list of locations containing the northing for the center of
the area-of-interest.}

\item{buffer}{Distance or list of distances added or subtracted to \code{(x,y)}
to create the area-of-interest. Can be 0 when used with \code{(x,y)} to
return projects providing coverage for point location(s). Can be a
vector of values corresponding to the number of objects in \code{aoi}
allowing a different buffer size for each object when \code{aoi} is a
\code{Spatial*} or \code{sf} object. \code{buffer} can be negative with
polygon features to reduce the area considered. However, you may end up
with weird shapes if the distance is larger than the width of the polygon.}

\item{shape}{Character string describing the shape of the sample area.
Valid values are \code{"square"} or \code{"circle"}. The buffer shape
is the same for all objects specified by \code{(x,y)} or \code{aoi}.}

\item{aoi}{\code{Spatial*} or \code{sf} object containing a point(s) or polygon(s)
describing the area(s) of interest. Can be points or polygons.}

\item{crs}{Valid \code{proj4string} string defining the coordinate
reference system of \code{(x,y)} or \code{aoi}. \code{crs} is required when using
\code{(x,y)}. It is optional when using \code{aoi}. This can also be a valid
\code{SRS_string} for use with the sp::CRS() function where it will be provided
as the \code{projargs} argument. \code{crs} can also be an EPSG code (numeric).}

\item{segments}{Number of segments to use when generating a circular
area of interest. When using a \code{SpatialPoint*} or \code{sf} object
with \code{shape = "circle"}, set \code{segments} to a rather large value (60
or higher) that is a multiple of 4. The \code{st_buffer} function from \code{sf} is used to
build the sample areas and it accepts the number of segments in a quarter
circle so small values for \code{segments} may not produce good circles.
Values for \code{segments} that are not a multiple of 4 will not
produce circles with the correct number of segments.}

\item{returnType}{Character string specifying the object type for the
polygon object returned by \code{prepareTargetDataLegacy} when \code{(x,y)} is
used to specify the area-of-interest. Valid values are \code{"Spatial"}
or \code{"sf"}. \code{returnType} is ignored when \code{aoi} is specified
and the return type will match the object type of \code{aoi}.}
}
\value{
A set of optionally buffered spatial features. The return type will
  be the same as the \code{aoi} type. When \code{(x,y)} is used,
  \code{returnType} specifies the object type returned by \code{prepareTargetDataLegacy}.
}
\description{
Prepare features for use when querying a lidar project or tile index to determine
available data coverage. The basic operation done by this function is to apply the
\code{buffer} to the features.
}
\details{
Prepare point or polygon data for use when querying to determine the lidar
  project or tile coverage. Typically this preparation is done by the queryUSGSProjectIndex
  or queryUSGSTileIndex functions but you can use prepareTargetDataLegacyu to build the
  query objects so they can be used for other purposes.

  Units for \code{buffer} are the same as the horizontal units for the input features
  so you shouldn't use data in LON-LAT with units of degrees. In addition, LON-LAT
  coordinates are not allowed when working with Spatial* return types and \code{(x,y)}
  inputs. If you must use LON-LAT coords, set returnType = "sf".

  Ideally, you should use a projection for the input \code{(x,y)} or \code{aoi} that
  preserves distances and areas so the buffered area is accurate. UTM is a good
  choice. Web Mercator does not preserve distance or areas so the actual area produced
  when buffering a point varies considerably as you go from mid to northern or
  southern latitudes. You can use the \code{computeClipBufferForCONUS} function
  to adjust the buffer width depending on the location of \code{(x,y)} or \code{aoi}.
  This isn't a perfect solution but it gets you close. More accurate results
  can be produced by projecting you \code{(x,y)} or \code{aoi} into UTM, calling
  \code{prepareTargetDataLegacy}, then reproject the returned features into the
  desired projection.

  \code{prepareTargetDataLegacy} is the original version of the \code{prepareTargetData}
  function in the package. It has been replaced by a new version of the function that
  projects features to UTM, applies the buffer, then projects feature back to the
  original projection. The new version produces more accurate features. This is
  especially true when using point features.
}
\examples{
prepareTargetDataLegacy(-13540901, 5806426, 180, shape = "circle",
  crs = sp::CRS(SRS_string="EPSG:3857")@projargs)
pt1 <- sf::st_point(c(-13540901, 5806426 + 500))
pt2 <- sf::st_point(c(-13540901 + 500, 5806426 - 500))
pt3 <- sf::st_point(c(-13540901 - 500, 5806426))
pt4 <- sf::st_point(c(-13540901 + 1000, 5806426 - 1000))
id <- c("P1", "P2", "P3", "P4")
x_sf <- sf::st_sf(data.frame(ID = id, stringsAsFactors = FALSE),
  geom = sf::st_sfc(pt1, pt2, pt3, pt4),
  crs = sp::CRS(SRS_string="EPSG:3857")@projargs)
samples <- prepareTargetDataLegacy(aoi = x_sf, buffer = 180)
}
