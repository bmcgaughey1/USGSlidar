% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SamplePoints.R
\name{generatePolygonSamplePoints}
\alias{generatePolygonSamplePoints}
\title{USGS Lidar Toolkit -- Create sample points for a set of polygon}
\usage{
generatePolygonSamplePoints(
  inputPolygons,
  IDColumnLabel = "",
  appendAttributes = TRUE,
  columnNameID = "",
  pattern = "hexagonal",
  polyBuffer = -1,
  gridSpacing = 5000,
  offset = c(0.5, 0.5),
  count = -1,
  perturb = TRUE,
  perturbMultiplier = 1,
  minArea = -1,
  seedColumnLabel = "",
  seed = -1,
  verbose = 0
)
}
\arguments{
\item{inputPolygons}{\code{Spatial*} or \code{sf} object containing the polygon(s) for
which you want sample points.}

\item{IDColumnLabel}{Character: Name of the column in the \code{inputPolygons} data to
be used to build the identifier for the sample points. If not specified, identifiers
for the sample points are simple sequential numbers starting at 1. The same sequence
of identifiers is generated for all polygons so you should set \code{appendAttributes}
to TRUE to ensure you have enough information to uniquely identify each sample point when
not specifying \code{IDColumnLabel}.}

\item{appendAttributes}{Logical: if TRUE, the fields for the \code{inputPolygons} are appended
to the fields of the returned point data. If FALSE, only a label field is added to
the fields of the return points. The label field is named \code{Label} unless
\code{columnNameID} is specified.}

\item{columnNameID}{Character: Name for the identifier field in the set of sample points.
If not specified, the name will be \code{"Label"}.}

\item{pattern}{Character indicating the desired sample pattern. \code{pattern} will be
passed to \code{spsample()}. Choices are: "random" for completely spatial random; "regular"
for regular (systematically aligned) sampling; and "hexagonal" for sampling on a hexagonal
lattice. While other options are available in (and will be passed to) \code{spsample()},
their behavior as used in this application is unknown.}

\item{polyBuffer}{Distance to reduce the size of the polygon(s) by applying \code{sf::st_buffer}
with \code{dist = -polyBuffer}. A value <= 0 will produce no buffer.}

\item{gridSpacing}{Desired grid size passed to \code{spsample()}.}

\item{offset}{Position of the regular sample grid in the unit cell [0,1] x [0,1]. The default
is \code{c(0.5,0.5)} placing the position of the grid at the center of the sample cell.
When \code{pattern = "regular"}, the effect of \code{offset} is easy to interpret.
However, when \code{pattern = "hexagonal"} or \code{pattern = "random"}, the effect
of \code{offset} is much harder to interpret.}

\item{count}{Desired number of sample points. You may not actually get back \code{count}
points depending on the interaction between the polygon shape, \code{buffer} and
\code{count)}. If between 0 and 1, \code{count} is interpreted as a proportion of
the number of sample points generated that should be returned. This is useful when
generating sample points for polygons that vary in size.}

\item{perturb}{Logical: If TRUE, point locations are randomly moved from the location
generated by \code{spsample()}. The distance moved is controlled by
\code{perturbMultiplier * gridSpacing}.}

\item{perturbMultiplier}{Multiplier > 0 used to adjust locations generated
by \code{spsample()}.}

\item{minArea}{Minimum area for polygons used to create sample points. This is the total
area covered by the feature so it might include several polygons. The area is evaluated
before and after the \code{buffer} is applied. If -1 (default), the minimum area is
computed as \code{gridSpacing^2 * 5}. If 0, sampling will be attempted for all features.
However, sample generation may fail for small features depending on the values for
\code{buffer} and \code{gridSpacing}.}

\item{seedColumnLabel}{Character: Name of the column in \code{inputPolygons} containing
an integer value used to initialize the random number generator. Using a field
unique to a polygon allows you to generate a consistent sample every time a particular
polygon is used. When \code{seedColumnLabel} is not specified, a single seed value
(if provided in \code{seed}) is used for all polygons. If a seed value is not provided
in \code{seed}, the random number generator is not seeded.}

\item{seed}{Seed for the random number generator to be applied before any sample
generation (outside the loop used to generate sample locations for each polygon in
\code{inputPolygons}).}

\item{verbose}{if > 0, output status information every \code{verbose} features
in \code{inputPolygons}.}
}
\value{
A set of sample point locations attributed with X, Y, and an identifier created
  using either \code{IDColumnLabel} and the sequential point number (when \code{IDColumnLabel}
  is specified) or just the sequential point number (when \code{IDColumnLabel} is not
  specified) and all columns from the \code{inputPolygons} data frame. The return type
  will be determined by the type of \code{inputPolygons}. If \code{inputPolygons} is
  a \code{Spatial*} type, the return will be a \code{SpatialPointsDataFrame} object and
  if \code{inputPolygons} is a simple features \code{(sf)} type, the return will be a
  simple features \code{(sf)} type.
}
\description{
Generate a set of sample points within a polygon. Given an input polygon,
create a set of sample points within the polygon. Multi-part polygons are allowed
and the number of sample points will be distributed over the parts.
}
\details{
There are 3 potential interactions between \code{gridSpacing} and \code{count}:
  Both have values > 0: \code{gridSpacing} controls the sample point spacing. If the number of
  sample points exceeds \code{count}, the set of points is sampled to produce \code{count} points.
  \code{count} > 0; \code{gridSpacing} = -1: point spacing is computed using \code{count} and the polygon
  area.
  \code{count} = -1; \code{gridSpacing} > 0: \code{gridSpacing} controls the sample point spacing and
  you get all sample points.

  The number of sample points may not exactly match \code{count} due to irregularities in the
  the polygon. If \code{count} is between 0 and 1, it is interpreted as the proportion of the
  sample points that should be returned. For example, if you want a 10 percent sample of the points
  located on a 100 meter grid, set \code{count = 0.1} and \code{gridSpacing = 100}.

  If you perturb the locations without using a \code{polyBuffer}, you can end up with points outside
  the polygon. The final set of sample points is intersected with the original polygon
  so the points outside the polygon are eliminated. However, this final clipping operation
  can mess up the \code{count} (number of sample points). This may not be a problem
  when \code{gridSpacing} and \code{count} have values (not = -1) because the sampling to reduce the number
  of points (if needed) occurs after the clipping operation.

  One caution with \code{polyBuffer}:
  If you specify a value for \code{polyBuffer} larger than the width of a polygon, you can essentially remove the
  polygon so you end up with no sample points. This is especially a problem when you have
  project polygons made up of several parts and some of the parts are small. Units for the buffer are
  the same as the horizontal units for the input feature so you shouldn't use data in LON-LAT with units
  of degrees.

  You can call this function with multiple polygons to generate a set of sample points for
  each polygon. Each set will have \code{count} points (at least the logic tries to generate \code{count} points).
}
