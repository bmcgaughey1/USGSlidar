% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/UtilityFunctions.R
\name{prepareTargetData}
\alias{prepareTargetData}
\title{USGS Lidar Toolkit -- Prepare Target Data}
\usage{
prepareTargetData(
  x = NULL,
  y = NULL,
  buffer = 0,
  shape = "square",
  aoi = NULL,
  crs = "",
  segments = 60,
  returnType = "sf",
  useLegacyBuffering = FALSE
)
}
\arguments{
\item{x}{Location or list of locations containing the easting for the center of
the area-of-interest.}

\item{y}{Location or list of locations containing the northing for the center of
the area-of-interest.}

\item{buffer}{Distance or list of distances added or subtracted to \code{(x,y)}
to create the area-of-interest. Can be 0 when used with \code{(x,y)} to
return projects providing coverage for point location(s). Can be a
vector of values corresponding to the number of objects in \code{aoi}
allowing a different buffer size for each object when \code{aoi} is a
\code{Spatial*} or \code{sf} object. \code{buffer} can be negative with
polygon features to reduce the area considered. However, you may end up
with weird shapes if the distance is larger than the width of the polygon.}

\item{shape}{Character string describing the shape of the sample area.
Valid values are \code{"square"} or \code{"circle"}. The buffer shape
is the same for all objects specified by \code{(x,y)} or \code{aoi}. For polygon
features, \code{shape} affects the way vertices are buffered. In most cases,
use \code{shape = "eound"} for the best result.}

\item{aoi}{\code{Spatial*} or \code{sf} object containing a point(s) or polygon(s)
describing the area(s) of interest. Can be points or polygons.}

\item{crs}{Valid \code{proj4string} string defining the coordinate reference
system of \code{(x,y)}. \code{crs} can also be an EPSG code (numeric).
\code{crs} is required when using \code{(x,y)}. \code{crs} is quietly ignored when using
\code{aoi}.}

\item{segments}{Number of segments to use when generating a circular
area of interest. When using a \code{SpatialPoint*} or \code{sf} object
with \code{shape = "circle"}, set \code{segments} to a rather large value (60
or higher) that is a multiple of 4. The \code{st_uffer} function from
\code{sf} is used to
build the sample areas and it accepts the number of segments in a quarter
circle so small values for \code{segments} may not produce good circles.
Values for \code{segments} that are not a multiple of 4 will not
produce circles with the correct number of segments.}

\item{returnType}{Character string specifying the object type for the
polygon object returned by \code{prepareTargetData} when \code{(x,y)} is
used to specify the area-of-interest. Valid values are \code{"Spatial"}
or \code{"sf"}. \code{returnType} is ignored when \code{aoi} is specified
and the return type will match the object type of \code{aoi}.}

\item{useLegacyBuffering}{Boolean flag indicating that the \code{buffer} should
be applied to features in their original projection. This was the original
behavior of \code{prepareTargetData} prior to changes in June 2023.}
}
\value{
A set of optionally buffered spatial features. The return type will
  be the same as the \code{aoi} type. When \code{(x,y)} is used,
  \code{returnType} specifies the object type returned by \code{prepareTargetData}.
}
\description{
Prepare features for use when querying a lidar project or tile index to determine
available data coverage. The basic operation done by this function is to apply the
\code{buffer} to the features.
}
\details{
Prepare point or polygon data for use when querying to determine a lidar
  project or tile coverage. Typically this function is called by the queryUSGSProjectIndex,
  queryUSGSTileIndex, or queryMPCTileIndex functions but you can use prepareTargetData to build the
  query objects so they can be used for other purposes.

  Units for \code{buffer} are always meters.

  In operation, features are first projected to WGS84 LON-LAT. Then the centroid of all
  features is computed and used to determine the UTM zone. Features are
  projected to UTM and the buffer is applied. Then the features
  are projected back to the original projection (or LON-LAT if applicable). As a result,
  the actual shape of the buffered area when providing point features may not
  be a perfect circle or square if the original projection does not preserve
  distances. If this behavior causes problems, you can specify \code{useLegacyBuffering = TRUE}
  to any of the query functions to have the buffer applied using the native
  projection of the input features.
}
\examples{
prepareTargetData(-13540901, 5806426, 180, shape = "circle",
  crs = sp::CRS(SRS_string="EPSG:3857")@projargs)
pt1 <- sf::st_point(c(-13540901, 5806426 + 500))
pt2 <- sf::st_point(c(-13540901 + 500, 5806426 - 500))
pt3 <- sf::st_point(c(-13540901 - 500, 5806426))
pt4 <- sf::st_point(c(-13540901 + 1000, 5806426 - 1000))
id <- c("P1", "P2", "P3", "P4")
x_sf <- sf::st_sf(data.frame(ID = id, stringsAsFactors = FALSE),
  geom = sf::st_sfc(pt1, pt2, pt3, pt4),
  crs = sp::CRS(SRS_string="EPSG:3857")@projargs)
samples <- prepareTargetData(aoi = x_sf, buffer = 180)
}
